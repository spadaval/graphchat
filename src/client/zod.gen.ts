// This file is auto-generated by @hey-api/openapi-ts

import { z } from 'zod';

export const zError = z.object({
    error: z.optional(z.object({
        code: z.optional(z.int()),
        message: z.optional(z.string()),
        type: z.optional(z.string())
    }))
});

export const zPropsResponse = z.object({
    default_generation_settings: z.optional(z.object({
        id: z.optional(z.int()),
        id_task: z.optional(z.int()),
        n_ctx: z.optional(z.int()),
        speculative: z.optional(z.boolean()),
        is_processing: z.optional(z.boolean()),
        params: z.optional(z.object({
            n_predict: z.optional(z.int()),
            seed: z.optional(z.int()),
            temperature: z.optional(z.number()),
            dynatemp_range: z.optional(z.number()),
            dynatemp_exponent: z.optional(z.number()),
            top_k: z.optional(z.int()),
            top_p: z.optional(z.number()),
            min_p: z.optional(z.number()),
            xtc_probability: z.optional(z.number()),
            xtc_threshold: z.optional(z.number()),
            typical_p: z.optional(z.number()),
            repeat_last_n: z.optional(z.int()),
            repeat_penalty: z.optional(z.number()),
            presence_penalty: z.optional(z.number()),
            frequency_penalty: z.optional(z.number()),
            dry_multiplier: z.optional(z.number()),
            dry_base: z.optional(z.number()),
            dry_allowed_length: z.optional(z.int()),
            dry_penalty_last_n: z.optional(z.int()),
            dry_sequence_breakers: z.optional(z.array(z.string())),
            mirostat: z.optional(z.int()),
            mirostat_tau: z.optional(z.number()),
            mirostat_eta: z.optional(z.number()),
            stop: z.optional(z.array(z.string())),
            max_tokens: z.optional(z.int()),
            n_keep: z.optional(z.int()),
            n_discard: z.optional(z.int()),
            ignore_eos: z.optional(z.boolean()),
            stream: z.optional(z.boolean()),
            n_probs: z.optional(z.int()),
            min_keep: z.optional(z.int()),
            grammar: z.optional(z.string()),
            samplers: z.optional(z.array(z.string())),
            'speculative.n_max': z.optional(z.int()),
            'speculative.n_min': z.optional(z.int()),
            'speculative.p_min': z.optional(z.number()),
            timings_per_token: z.optional(z.boolean())
        })),
        prompt: z.optional(z.string()),
        next_token: z.optional(z.object({
            has_next_token: z.optional(z.boolean()),
            has_new_line: z.optional(z.boolean()),
            n_remain: z.optional(z.int()),
            n_decoded: z.optional(z.int()),
            stopping_word: z.optional(z.string())
        }))
    })),
    total_slots: z.optional(z.int()),
    model_path: z.optional(z.string()),
    chat_template: z.optional(z.string()),
    modalities: z.optional(z.object({
        vision: z.optional(z.boolean())
    })),
    build_info: z.optional(z.string())
});

export const zSlot = z.object({
    id: z.optional(z.int()),
    id_task: z.optional(z.int()),
    n_ctx: z.optional(z.int()),
    speculative: z.optional(z.boolean()),
    is_processing: z.optional(z.boolean()),
    params: z.optional(z.object({
        n_predict: z.optional(z.int()),
        seed: z.optional(z.int()),
        temperature: z.optional(z.number()),
        dynatemp_range: z.optional(z.number()),
        dynatemp_exponent: z.optional(z.number()),
        top_k: z.optional(z.int()),
        top_p: z.optional(z.number()),
        min_p: z.optional(z.number()),
        xtc_probability: z.optional(z.number()),
        xtc_threshold: z.optional(z.number()),
        typical_p: z.optional(z.number()),
        repeat_last_n: z.optional(z.int()),
        repeat_penalty: z.optional(z.number()),
        presence_penalty: z.optional(z.number()),
        frequency_penalty: z.optional(z.number()),
        dry_multiplier: z.optional(z.number()),
        dry_base: z.optional(z.number()),
        dry_allowed_length: z.optional(z.int()),
        dry_penalty_last_n: z.optional(z.int()),
        dry_sequence_breakers: z.optional(z.array(z.string())),
        mirostat: z.optional(z.int()),
        mirostat_tau: z.optional(z.number()),
        mirostat_eta: z.optional(z.number()),
        stop: z.optional(z.array(z.string())),
        max_tokens: z.optional(z.int()),
        n_keep: z.optional(z.int()),
        n_discard: z.optional(z.int()),
        ignore_eos: z.optional(z.boolean()),
        stream: z.optional(z.boolean()),
        n_probs: z.optional(z.int()),
        min_keep: z.optional(z.int()),
        grammar: z.optional(z.string()),
        samplers: z.optional(z.array(z.string())),
        'speculative.n_max': z.optional(z.int()),
        'speculative.n_min': z.optional(z.int()),
        'speculative.p_min': z.optional(z.number()),
        timings_per_token: z.optional(z.boolean())
    })),
    prompt: z.optional(z.string()),
    next_token: z.optional(z.object({
        has_next_token: z.optional(z.boolean()),
        has_new_line: z.optional(z.boolean()),
        n_remain: z.optional(z.int()),
        n_decoded: z.optional(z.int()),
        stopping_word: z.optional(z.string())
    }))
});

export const zSlotSaveResponse = z.object({
    id_slot: z.optional(z.int()),
    filename: z.optional(z.string()),
    n_saved: z.optional(z.int()),
    n_written: z.optional(z.int()),
    timings: z.optional(z.object({
        save_ms: z.optional(z.number())
    }))
});

export const zSlotRestoreResponse = z.object({
    id_slot: z.optional(z.int()),
    filename: z.optional(z.string()),
    n_restored: z.optional(z.int()),
    n_read: z.optional(z.int()),
    timings: z.optional(z.object({
        restore_ms: z.optional(z.number())
    }))
});

export const zSlotEraseResponse = z.object({
    id_slot: z.optional(z.int()),
    n_erased: z.optional(z.int())
});

export const zGetHealthData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

/**
 * Server is healthy
 */
export const zGetHealthResponse = z.object({
    status: z.optional(z.string())
});

export const zGetPropsData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

/**
 * Successful response
 */
export const zGetPropsResponse = zPropsResponse;

export const zPostPropsData = z.object({
    body: z.record(z.string(), z.unknown()),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

export const zGetSlotsData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.object({
        fail_on_no_slot: z.optional(z.unknown())
    }))
});

/**
 * Successful response
 */
export const zGetSlotsResponse = z.array(zSlot);

export const zPostSlotsByIdSlotData = z.object({
    body: z.optional(z.object({
        filename: z.optional(z.string())
    })),
    path: z.object({
        id_slot: z.int()
    }),
    query: z.object({
        action: z.enum([
            'save',
            'restore',
            'erase'
        ])
    })
});

/**
 * Action completed successfully
 */
export const zPostSlotsByIdSlotResponse = z.union([
    zSlotSaveResponse,
    zSlotRestoreResponse,
    zSlotEraseResponse
]);

export const zPostCompletionData = z.object({
    body: z.object({
        prompt: z.union([
            z.string(),
            z.array(z.unknown()),
            z.object({
                prompt_string: z.string(),
                multimodal_data: z.optional(z.array(z.string()))
            })
        ]),
        temperature: z.optional(z.number()).default(0.8),
        top_k: z.optional(z.int()).default(40),
        top_p: z.optional(z.number()).default(0.95),
        n_predict: z.optional(z.int()).default(-1),
        stream: z.optional(z.boolean()).default(false),
        stop: z.optional(z.array(z.string())).default([]),
        repeat_penalty: z.optional(z.number()).default(1.1),
        presence_penalty: z.optional(z.number()).default(0),
        frequency_penalty: z.optional(z.number()).default(0),
        mirostat: z.optional(z.unknown()),
        mirostat_tau: z.optional(z.number()).default(5),
        mirostat_eta: z.optional(z.number()).default(0.1),
        seed: z.optional(z.int()).default(-1),
        logit_bias: z.optional(z.union([
            z.array(z.array(z.unknown())),
            z.record(z.string(), z.unknown())
        ])),
        n_probs: z.optional(z.int()).default(0),
        cache_prompt: z.optional(z.boolean()).default(true),
        return_tokens: z.optional(z.boolean()).default(false)
    }),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

/**
 * Successful response
 */
export const zPostCompletionResponse = z.object({
    content: z.optional(z.string()),
    tokens: z.optional(z.array(z.int())),
    stop: z.optional(z.boolean()),
    model: z.optional(z.string()),
    prompt: z.optional(z.string()),
    stop_type: z.optional(z.enum([
        'none',
        'eos',
        'limit',
        'word'
    ])),
    stopping_word: z.optional(z.string()),
    generation_settings: z.optional(z.object({
        n_predict: z.optional(z.int()),
        seed: z.optional(z.int()),
        temperature: z.optional(z.number()),
        dynatemp_range: z.optional(z.number()),
        dynatemp_exponent: z.optional(z.number()),
        top_k: z.optional(z.int()),
        top_p: z.optional(z.number()),
        min_p: z.optional(z.number()),
        xtc_probability: z.optional(z.number()),
        xtc_threshold: z.optional(z.number()),
        typical_p: z.optional(z.number()),
        repeat_last_n: z.optional(z.int()),
        repeat_penalty: z.optional(z.number()),
        presence_penalty: z.optional(z.number()),
        frequency_penalty: z.optional(z.number()),
        dry_multiplier: z.optional(z.number()),
        dry_base: z.optional(z.number()),
        dry_allowed_length: z.optional(z.int()),
        dry_penalty_last_n: z.optional(z.int()),
        dry_sequence_breakers: z.optional(z.array(z.string())),
        mirostat: z.optional(z.int()),
        mirostat_tau: z.optional(z.number()),
        mirostat_eta: z.optional(z.number()),
        stop: z.optional(z.array(z.string())),
        max_tokens: z.optional(z.int()),
        n_keep: z.optional(z.int()),
        n_discard: z.optional(z.int()),
        ignore_eos: z.optional(z.boolean()),
        stream: z.optional(z.boolean()),
        n_probs: z.optional(z.int()),
        min_keep: z.optional(z.int()),
        grammar: z.optional(z.string()),
        samplers: z.optional(z.array(z.string())),
        'speculative.n_max': z.optional(z.int()),
        'speculative.n_min': z.optional(z.int()),
        'speculative.p_min': z.optional(z.number()),
        timings_per_token: z.optional(z.boolean())
    })),
    timings: z.optional(z.object({
        predicted_per_second: z.optional(z.number())
    })),
    tokens_cached: z.optional(z.int()),
    tokens_evaluated: z.optional(z.int()),
    truncated: z.optional(z.boolean()),
    completion_probabilities: z.optional(z.array(z.object({
        id: z.optional(z.int()),
        logprob: z.optional(z.number()),
        token: z.optional(z.string()),
        bytes: z.optional(z.array(z.int())),
        top_logprobs: z.optional(z.array(z.object({
            id: z.optional(z.int()),
            logprob: z.optional(z.number()),
            token: z.optional(z.string()),
            bytes: z.optional(z.array(z.int()))
        })))
    })))
});

export const zPostTokenizeData = z.object({
    body: z.object({
        content: z.string(),
        add_special: z.optional(z.boolean()).default(false),
        parse_special: z.optional(z.boolean()).default(true),
        with_pieces: z.optional(z.boolean()).default(false)
    }),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

/**
 * Successful response
 */
export const zPostTokenizeResponse = z.union([
    z.object({
        tokens: z.optional(z.array(z.int()))
    }),
    z.object({
        tokens: z.optional(z.array(z.object({
            id: z.optional(z.int()),
            piece: z.optional(z.union([
                z.string(),
                z.array(z.int())
            ]))
        })))
    })
]);

export const zPostEmbeddingsData = z.object({
    body: z.object({
        content: z.string(),
        embd_normalize: z.optional(z.unknown())
    }),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

/**
 * Successful response
 */
export const zPostEmbeddingsResponse = z.array(z.object({
    index: z.optional(z.int()),
    embedding: z.optional(z.union([
        z.array(z.number()),
        z.array(z.array(z.number()))
    ]))
}));

export const zPostRerankingData = z.object({
    body: z.object({
        query: z.string(),
        documents: z.array(z.string())
    }),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

/**
 * Successful response
 */
export const zPostRerankingResponse = z.array(z.object({
    index: z.optional(z.int()),
    score: z.optional(z.number()),
    document: z.optional(z.string())
}));

export const zPostInfillData = z.object({
    body: z.object({
        input_prefix: z.optional(z.string()),
        input_suffix: z.optional(z.string()),
        input_extra: z.optional(z.array(z.object({
            filename: z.optional(z.string()),
            text: z.optional(z.string())
        }))),
        prompt: z.optional(z.string())
    }),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

/**
 * Successful response
 */
export const zPostInfillResponse = z.object({
    content: z.optional(z.string()),
    tokens: z.optional(z.array(z.int())),
    stop: z.optional(z.boolean())
});

export const zPostDetokenizeData = z.object({
    body: z.object({
        tokens: z.array(z.int())
    }),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

/**
 * Successful response
 */
export const zPostDetokenizeResponse = z.object({
    content: z.optional(z.string())
});

export const zPostApplyTemplateData = z.object({
    body: z.object({
        messages: z.array(z.object({
            role: z.enum([
                'system',
                'user',
                'assistant'
            ]),
            content: z.string()
        }))
    }),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

/**
 * Successful response
 */
export const zPostApplyTemplateResponse = z.object({
    prompt: z.optional(z.string())
});

export const zGetLoraAdaptersData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

/**
 * Successful response
 */
export const zGetLoraAdaptersResponse = z.array(z.object({
    id: z.optional(z.int()),
    path: z.optional(z.string()),
    scale: z.optional(z.number())
}));

export const zPostLoraAdaptersData = z.object({
    body: z.array(z.object({
        id: z.int(),
        scale: z.number()
    })),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

export const zGetMetricsData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

/**
 * Metrics data
 */
export const zGetMetricsResponse = z.string();

export const zPostV1ChatCompletionsData = z.object({
    body: z.object({
        model: z.string(),
        messages: z.array(z.object({
            role: z.enum([
                'system',
                'user',
                'assistant'
            ]),
            content: z.union([
                z.string(),
                z.array(z.object({
                    type: z.optional(z.string()),
                    text: z.optional(z.string()),
                    image_url: z.optional(z.object({
                        url: z.optional(z.string())
                    }))
                }))
            ])
        })),
        temperature: z.optional(z.number()).default(0.8),
        top_p: z.optional(z.number()).default(0.95),
        n: z.optional(z.int()).default(1),
        stream: z.optional(z.boolean()).default(false),
        stop: z.optional(z.union([
            z.string(),
            z.array(z.string())
        ])),
        max_tokens: z.optional(z.int()).default(2048),
        presence_penalty: z.optional(z.number()).default(0),
        frequency_penalty: z.optional(z.number()).default(0),
        logit_bias: z.optional(z.record(z.string(), z.unknown())),
        user: z.optional(z.string()),
        response_format: z.optional(z.object({
            type: z.optional(z.string()),
            schema: z.optional(z.record(z.string(), z.unknown()))
        })),
        chat_template_kwargs: z.optional(z.record(z.string(), z.unknown())),
        reasoning_format: z.optional(z.string()),
        thinking_forced_open: z.optional(z.boolean()),
        parse_tool_calls: z.optional(z.boolean()),
        parallel_tool_calls: z.optional(z.boolean())
    }),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

/**
 * Successful response
 */
export const zPostV1ChatCompletionsResponse = z.object({
    id: z.optional(z.string()),
    object: z.optional(z.string()),
    created: z.optional(z.int()),
    model: z.optional(z.string()),
    choices: z.optional(z.array(z.object({
        index: z.optional(z.int()),
        message: z.optional(z.object({
            role: z.optional(z.string()),
            content: z.optional(z.string())
        })),
        finish_reason: z.optional(z.string())
    }))),
    usage: z.optional(z.object({
        prompt_tokens: z.optional(z.int()),
        completion_tokens: z.optional(z.int()),
        total_tokens: z.optional(z.int())
    }))
});

export const zPostV1EmbeddingsData = z.object({
    body: z.object({
        model: z.string(),
        input: z.union([
            z.string(),
            z.array(z.string())
        ]),
        encoding_format: z.optional(z.string()).default('float'),
        user: z.optional(z.string())
    }),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

/**
 * Successful response
 */
export const zPostV1EmbeddingsResponse = z.object({
    object: z.optional(z.string()),
    data: z.optional(z.array(z.object({
        object: z.optional(z.string()),
        embedding: z.optional(z.array(z.number())),
        index: z.optional(z.int())
    }))),
    model: z.optional(z.string()),
    usage: z.optional(z.object({
        prompt_tokens: z.optional(z.int()),
        total_tokens: z.optional(z.int())
    }))
});

export const zGetV1ModelsData = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

/**
 * Successful response
 */
export const zGetV1ModelsResponse = z.object({
    object: z.optional(z.string()),
    data: z.optional(z.array(z.object({
        id: z.optional(z.string()),
        object: z.optional(z.string()),
        created: z.optional(z.int()),
        owned_by: z.optional(z.string()),
        meta: z.optional(z.object({
            vocab_type: z.optional(z.int()),
            n_vocab: z.optional(z.int()),
            n_ctx_train: z.optional(z.int()),
            n_embd: z.optional(z.int()),
            n_params: z.optional(z.int()),
            size: z.optional(z.int())
        }))
    })))
});