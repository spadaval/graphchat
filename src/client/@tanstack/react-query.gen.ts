// This file is auto-generated by @hey-api/openapi-ts

import { type Options, getHealth, getProps, postProps, getSlots, postSlotsByIdSlot, postCompletion, postTokenize, postEmbeddings, postReranking, postInfill, postDetokenize, postApplyTemplate, getLoraAdapters, postLoraAdapters, getMetrics, postV1ChatCompletions, postV1Embeddings, getV1Models } from '../sdk.gen';
import { queryOptions, type UseMutationOptions, type DefaultError } from '@tanstack/react-query';
import type { GetHealthData, GetPropsData, PostPropsData, PostPropsError, GetSlotsData, PostSlotsByIdSlotData, PostSlotsByIdSlotError, PostSlotsByIdSlotResponse, PostCompletionData, PostCompletionError, PostCompletionResponse, PostTokenizeData, PostTokenizeResponse, PostEmbeddingsData, PostEmbeddingsResponse, PostRerankingData, PostRerankingResponse, PostInfillData, PostInfillResponse, PostDetokenizeData, PostDetokenizeResponse, PostApplyTemplateData, PostApplyTemplateResponse, GetLoraAdaptersData, PostLoraAdaptersData, GetMetricsData, PostV1ChatCompletionsData, PostV1ChatCompletionsResponse, PostV1EmbeddingsData, PostV1EmbeddingsResponse, GetV1ModelsData } from '../types.gen';
import { client as _heyApiClient } from '../client.gen';

export type QueryKey<TOptions extends Options> = [
    Pick<TOptions, 'baseUrl' | 'body' | 'headers' | 'path' | 'query'> & {
        _id: string;
        _infinite?: boolean;
        tags?: ReadonlyArray<string>;
    }
];

const createQueryKey = <TOptions extends Options>(id: string, options?: TOptions, infinite?: boolean, tags?: ReadonlyArray<string>): [
    QueryKey<TOptions>[0]
] => {
    const params: QueryKey<TOptions>[0] = { _id: id, baseUrl: options?.baseUrl || (options?.client ?? _heyApiClient).getConfig().baseUrl } as QueryKey<TOptions>[0];
    if (infinite) {
        params._infinite = infinite;
    }
    if (tags) {
        params.tags = tags;
    }
    if (options?.body) {
        params.body = options.body;
    }
    if (options?.headers) {
        params.headers = options.headers;
    }
    if (options?.path) {
        params.path = options.path;
    }
    if (options?.query) {
        params.query = options.query;
    }
    return [
        params
    ];
};

export const getHealthQueryKey = (options?: Options<GetHealthData>) => createQueryKey('getHealth', options);

/**
 * Health check
 */
export const getHealthOptions = (options?: Options<GetHealthData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getHealth({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getHealthQueryKey(options)
    });
};

export const getPropsQueryKey = (options?: Options<GetPropsData>) => createQueryKey('getProps', options);

/**
 * Get server global properties
 */
export const getPropsOptions = (options?: Options<GetPropsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getProps({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getPropsQueryKey(options)
    });
};

/**
 * Change server global properties
 * Requires server to be started with --props flag
 */
export const postPropsMutation = (options?: Partial<Options<PostPropsData>>): UseMutationOptions<unknown, PostPropsError, Options<PostPropsData>> => {
    const mutationOptions: UseMutationOptions<unknown, PostPropsError, Options<PostPropsData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await postProps({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getSlotsQueryKey = (options?: Options<GetSlotsData>) => createQueryKey('getSlots', options);

/**
 * Get current slots processing state
 * Disabled by default, enable with --slots flag. Use ?fail_on_no_slot=1 to return 503 when no slots available
 */
export const getSlotsOptions = (options?: Options<GetSlotsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getSlots({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getSlotsQueryKey(options)
    });
};

/**
 * Manage slot actions
 */
export const postSlotsByIdSlotMutation = (options?: Partial<Options<PostSlotsByIdSlotData>>): UseMutationOptions<PostSlotsByIdSlotResponse, PostSlotsByIdSlotError, Options<PostSlotsByIdSlotData>> => {
    const mutationOptions: UseMutationOptions<PostSlotsByIdSlotResponse, PostSlotsByIdSlotError, Options<PostSlotsByIdSlotData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await postSlotsByIdSlot({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Generate completion
 */
export const postCompletionMutation = (options?: Partial<Options<PostCompletionData>>): UseMutationOptions<PostCompletionResponse, PostCompletionError, Options<PostCompletionData>> => {
    const mutationOptions: UseMutationOptions<PostCompletionResponse, PostCompletionError, Options<PostCompletionData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await postCompletion({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Tokenize text
 */
export const postTokenizeMutation = (options?: Partial<Options<PostTokenizeData>>): UseMutationOptions<PostTokenizeResponse, DefaultError, Options<PostTokenizeData>> => {
    const mutationOptions: UseMutationOptions<PostTokenizeResponse, DefaultError, Options<PostTokenizeData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await postTokenize({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Generate embeddings (non-OpenAI-compatible)
 */
export const postEmbeddingsMutation = (options?: Partial<Options<PostEmbeddingsData>>): UseMutationOptions<PostEmbeddingsResponse, DefaultError, Options<PostEmbeddingsData>> => {
    const mutationOptions: UseMutationOptions<PostEmbeddingsResponse, DefaultError, Options<PostEmbeddingsData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await postEmbeddings({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Rerank documents according to a given query
 */
export const postRerankingMutation = (options?: Partial<Options<PostRerankingData>>): UseMutationOptions<PostRerankingResponse, DefaultError, Options<PostRerankingData>> => {
    const mutationOptions: UseMutationOptions<PostRerankingResponse, DefaultError, Options<PostRerankingData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await postReranking({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * For code infilling
 */
export const postInfillMutation = (options?: Partial<Options<PostInfillData>>): UseMutationOptions<PostInfillResponse, DefaultError, Options<PostInfillData>> => {
    const mutationOptions: UseMutationOptions<PostInfillResponse, DefaultError, Options<PostInfillData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await postInfill({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Convert tokens to text
 */
export const postDetokenizeMutation = (options?: Partial<Options<PostDetokenizeData>>): UseMutationOptions<PostDetokenizeResponse, DefaultError, Options<PostDetokenizeData>> => {
    const mutationOptions: UseMutationOptions<PostDetokenizeResponse, DefaultError, Options<PostDetokenizeData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await postDetokenize({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Apply chat template to a conversation
 */
export const postApplyTemplateMutation = (options?: Partial<Options<PostApplyTemplateData>>): UseMutationOptions<PostApplyTemplateResponse, DefaultError, Options<PostApplyTemplateData>> => {
    const mutationOptions: UseMutationOptions<PostApplyTemplateResponse, DefaultError, Options<PostApplyTemplateData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await postApplyTemplate({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getLoraAdaptersQueryKey = (options?: Options<GetLoraAdaptersData>) => createQueryKey('getLoraAdapters', options);

/**
 * Get list of all LoRA adapters
 */
export const getLoraAdaptersOptions = (options?: Options<GetLoraAdaptersData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getLoraAdapters({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getLoraAdaptersQueryKey(options)
    });
};

/**
 * Set list of LoRA adapters
 */
export const postLoraAdaptersMutation = (options?: Partial<Options<PostLoraAdaptersData>>): UseMutationOptions<unknown, DefaultError, Options<PostLoraAdaptersData>> => {
    const mutationOptions: UseMutationOptions<unknown, DefaultError, Options<PostLoraAdaptersData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await postLoraAdapters({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getMetricsQueryKey = (options?: Options<GetMetricsData>) => createQueryKey('getMetrics', options);

/**
 * Prometheus compatible metrics exporter
 */
export const getMetricsOptions = (options?: Options<GetMetricsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getMetrics({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getMetricsQueryKey(options)
    });
};

/**
 * Chat Completions (OpenAI-compatible)
 */
export const postV1ChatCompletionsMutation = (options?: Partial<Options<PostV1ChatCompletionsData>>): UseMutationOptions<PostV1ChatCompletionsResponse, DefaultError, Options<PostV1ChatCompletionsData>> => {
    const mutationOptions: UseMutationOptions<PostV1ChatCompletionsResponse, DefaultError, Options<PostV1ChatCompletionsData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await postV1ChatCompletions({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Generate embeddings (OpenAI-compatible)
 */
export const postV1EmbeddingsMutation = (options?: Partial<Options<PostV1EmbeddingsData>>): UseMutationOptions<PostV1EmbeddingsResponse, DefaultError, Options<PostV1EmbeddingsData>> => {
    const mutationOptions: UseMutationOptions<PostV1EmbeddingsResponse, DefaultError, Options<PostV1EmbeddingsData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await postV1Embeddings({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getV1ModelsQueryKey = (options?: Options<GetV1ModelsData>) => createQueryKey('getV1Models', options);

/**
 * List models (OpenAI-compatible)
 */
export const getV1ModelsOptions = (options?: Options<GetV1ModelsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getV1Models({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getV1ModelsQueryKey(options)
    });
};