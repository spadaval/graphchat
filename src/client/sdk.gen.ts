// This file is auto-generated by @hey-api/openapi-ts

import type { Options as ClientOptions, TDataShape, Client } from './client';
import type { GetHealthData, GetHealthResponses, GetHealthErrors, GetPropsData, GetPropsResponses, PostPropsData, PostPropsResponses, PostPropsErrors, GetSlotsData, GetSlotsResponses, GetSlotsErrors, PostSlotsByIdSlotData, PostSlotsByIdSlotResponses, PostSlotsByIdSlotErrors, PostCompletionData, PostCompletionResponses, PostCompletionErrors, PostTokenizeData, PostTokenizeResponses, PostEmbeddingsData, PostEmbeddingsResponses, PostRerankingData, PostRerankingResponses, PostInfillData, PostInfillResponses, PostDetokenizeData, PostDetokenizeResponses, PostApplyTemplateData, PostApplyTemplateResponses, GetLoraAdaptersData, GetLoraAdaptersResponses, PostLoraAdaptersData, PostLoraAdaptersResponses, GetMetricsData, GetMetricsResponses, PostV1ChatCompletionsData, PostV1ChatCompletionsResponses, PostV1EmbeddingsData, PostV1EmbeddingsResponses, GetV1ModelsData, GetV1ModelsResponses } from './types.gen';
import { zGetHealthData, zGetHealthResponse, zGetPropsData, zGetPropsResponse, zPostPropsData, zGetSlotsData, zGetSlotsResponse, zPostSlotsByIdSlotData, zPostSlotsByIdSlotResponse, zPostCompletionData, zPostCompletionResponse, zPostTokenizeData, zPostTokenizeResponse, zPostEmbeddingsData, zPostEmbeddingsResponse, zPostRerankingData, zPostRerankingResponse, zPostInfillData, zPostInfillResponse, zPostDetokenizeData, zPostDetokenizeResponse, zPostApplyTemplateData, zPostApplyTemplateResponse, zGetLoraAdaptersData, zGetLoraAdaptersResponse, zPostLoraAdaptersData, zGetMetricsData, zGetMetricsResponse, zPostV1ChatCompletionsData, zPostV1ChatCompletionsResponse, zPostV1EmbeddingsData, zPostV1EmbeddingsResponse, zGetV1ModelsData, zGetV1ModelsResponse } from './zod.gen';
import { client as _heyApiClient } from './client.gen';

export type Options<TData extends TDataShape = TDataShape, ThrowOnError extends boolean = boolean> = ClientOptions<TData, ThrowOnError> & {
    /**
     * You can provide a client instance returned by `createClient()` instead of
     * individual options. This might be also useful if you want to implement a
     * custom client.
     */
    client?: Client;
    /**
     * You can pass arbitrary values through the `meta` object. This can be
     * used to access values that aren't defined as part of the SDK function.
     */
    meta?: Record<string, unknown>;
};

/**
 * Health check
 */
export const getHealth = <ThrowOnError extends boolean = false>(options?: Options<GetHealthData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).get<GetHealthResponses, GetHealthErrors, ThrowOnError>({
        requestValidator: async (data) => {
            return await zGetHealthData.parseAsync(data);
        },
        responseValidator: async (data) => {
            return await zGetHealthResponse.parseAsync(data);
        },
        url: '/health',
        ...options
    });
};

/**
 * Get server global properties
 */
export const getProps = <ThrowOnError extends boolean = false>(options?: Options<GetPropsData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).get<GetPropsResponses, unknown, ThrowOnError>({
        requestValidator: async (data) => {
            return await zGetPropsData.parseAsync(data);
        },
        responseValidator: async (data) => {
            return await zGetPropsResponse.parseAsync(data);
        },
        url: '/props',
        ...options
    });
};

/**
 * Change server global properties
 * Requires server to be started with --props flag
 */
export const postProps = <ThrowOnError extends boolean = false>(options: Options<PostPropsData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<PostPropsResponses, PostPropsErrors, ThrowOnError>({
        requestValidator: async (data) => {
            return await zPostPropsData.parseAsync(data);
        },
        url: '/props',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Get current slots processing state
 * Disabled by default, enable with --slots flag. Use ?fail_on_no_slot=1 to return 503 when no slots available
 */
export const getSlots = <ThrowOnError extends boolean = false>(options?: Options<GetSlotsData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).get<GetSlotsResponses, GetSlotsErrors, ThrowOnError>({
        requestValidator: async (data) => {
            return await zGetSlotsData.parseAsync(data);
        },
        responseValidator: async (data) => {
            return await zGetSlotsResponse.parseAsync(data);
        },
        url: '/slots',
        ...options
    });
};

/**
 * Manage slot actions
 */
export const postSlotsByIdSlot = <ThrowOnError extends boolean = false>(options: Options<PostSlotsByIdSlotData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<PostSlotsByIdSlotResponses, PostSlotsByIdSlotErrors, ThrowOnError>({
        requestValidator: async (data) => {
            return await zPostSlotsByIdSlotData.parseAsync(data);
        },
        responseValidator: async (data) => {
            return await zPostSlotsByIdSlotResponse.parseAsync(data);
        },
        url: '/slots/{id_slot}',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Generate completion
 */
export const postCompletion = <ThrowOnError extends boolean = false>(options: Options<PostCompletionData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<PostCompletionResponses, PostCompletionErrors, ThrowOnError>({
        requestValidator: async (data) => {
            return await zPostCompletionData.parseAsync(data);
        },
        responseValidator: async (data) => {
            return await zPostCompletionResponse.parseAsync(data);
        },
        url: '/completion',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Tokenize text
 */
export const postTokenize = <ThrowOnError extends boolean = false>(options: Options<PostTokenizeData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<PostTokenizeResponses, unknown, ThrowOnError>({
        requestValidator: async (data) => {
            return await zPostTokenizeData.parseAsync(data);
        },
        responseValidator: async (data) => {
            return await zPostTokenizeResponse.parseAsync(data);
        },
        url: '/tokenize',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Generate embeddings (non-OpenAI-compatible)
 */
export const postEmbeddings = <ThrowOnError extends boolean = false>(options: Options<PostEmbeddingsData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<PostEmbeddingsResponses, unknown, ThrowOnError>({
        requestValidator: async (data) => {
            return await zPostEmbeddingsData.parseAsync(data);
        },
        responseValidator: async (data) => {
            return await zPostEmbeddingsResponse.parseAsync(data);
        },
        url: '/embeddings',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Rerank documents according to a given query
 */
export const postReranking = <ThrowOnError extends boolean = false>(options: Options<PostRerankingData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<PostRerankingResponses, unknown, ThrowOnError>({
        requestValidator: async (data) => {
            return await zPostRerankingData.parseAsync(data);
        },
        responseValidator: async (data) => {
            return await zPostRerankingResponse.parseAsync(data);
        },
        url: '/reranking',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * For code infilling
 */
export const postInfill = <ThrowOnError extends boolean = false>(options: Options<PostInfillData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<PostInfillResponses, unknown, ThrowOnError>({
        requestValidator: async (data) => {
            return await zPostInfillData.parseAsync(data);
        },
        responseValidator: async (data) => {
            return await zPostInfillResponse.parseAsync(data);
        },
        url: '/infill',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Convert tokens to text
 */
export const postDetokenize = <ThrowOnError extends boolean = false>(options: Options<PostDetokenizeData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<PostDetokenizeResponses, unknown, ThrowOnError>({
        requestValidator: async (data) => {
            return await zPostDetokenizeData.parseAsync(data);
        },
        responseValidator: async (data) => {
            return await zPostDetokenizeResponse.parseAsync(data);
        },
        url: '/detokenize',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Apply chat template to a conversation
 */
export const postApplyTemplate = <ThrowOnError extends boolean = false>(options: Options<PostApplyTemplateData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<PostApplyTemplateResponses, unknown, ThrowOnError>({
        requestValidator: async (data) => {
            return await zPostApplyTemplateData.parseAsync(data);
        },
        responseValidator: async (data) => {
            return await zPostApplyTemplateResponse.parseAsync(data);
        },
        url: '/apply-template',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Get list of all LoRA adapters
 */
export const getLoraAdapters = <ThrowOnError extends boolean = false>(options?: Options<GetLoraAdaptersData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).get<GetLoraAdaptersResponses, unknown, ThrowOnError>({
        requestValidator: async (data) => {
            return await zGetLoraAdaptersData.parseAsync(data);
        },
        responseValidator: async (data) => {
            return await zGetLoraAdaptersResponse.parseAsync(data);
        },
        url: '/lora-adapters',
        ...options
    });
};

/**
 * Set list of LoRA adapters
 */
export const postLoraAdapters = <ThrowOnError extends boolean = false>(options: Options<PostLoraAdaptersData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<PostLoraAdaptersResponses, unknown, ThrowOnError>({
        requestValidator: async (data) => {
            return await zPostLoraAdaptersData.parseAsync(data);
        },
        url: '/lora-adapters',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Prometheus compatible metrics exporter
 */
export const getMetrics = <ThrowOnError extends boolean = false>(options?: Options<GetMetricsData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).get<GetMetricsResponses, unknown, ThrowOnError>({
        requestValidator: async (data) => {
            return await zGetMetricsData.parseAsync(data);
        },
        responseValidator: async (data) => {
            return await zGetMetricsResponse.parseAsync(data);
        },
        url: '/metrics',
        ...options
    });
};

/**
 * Chat Completions (OpenAI-compatible)
 */
export const postV1ChatCompletions = <ThrowOnError extends boolean = false>(options: Options<PostV1ChatCompletionsData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<PostV1ChatCompletionsResponses, unknown, ThrowOnError>({
        requestValidator: async (data) => {
            return await zPostV1ChatCompletionsData.parseAsync(data);
        },
        responseValidator: async (data) => {
            return await zPostV1ChatCompletionsResponse.parseAsync(data);
        },
        url: '/v1/chat/completions',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Generate embeddings (OpenAI-compatible)
 */
export const postV1Embeddings = <ThrowOnError extends boolean = false>(options: Options<PostV1EmbeddingsData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<PostV1EmbeddingsResponses, unknown, ThrowOnError>({
        requestValidator: async (data) => {
            return await zPostV1EmbeddingsData.parseAsync(data);
        },
        responseValidator: async (data) => {
            return await zPostV1EmbeddingsResponse.parseAsync(data);
        },
        url: '/v1/embeddings',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * List models (OpenAI-compatible)
 */
export const getV1Models = <ThrowOnError extends boolean = false>(options?: Options<GetV1ModelsData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).get<GetV1ModelsResponses, unknown, ThrowOnError>({
        requestValidator: async (data) => {
            return await zGetV1ModelsData.parseAsync(data);
        },
        responseValidator: async (data) => {
            return await zGetV1ModelsResponse.parseAsync(data);
        },
        url: '/v1/models',
        ...options
    });
};